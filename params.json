{"name":"Wookiee-cluster","tagline":"Wookiee Component - Cluster","body":"# Wookiee - Distributed Messaging (Cluster Component)\r\n\r\n[![Build Status](https://travis-ci.org/Webtrends/wookiee-cluster.svg?branch=master)](https://travis-ci.org/Webtrends/wookiee-cluster) [![Coverage Status](https://coveralls.io/repos/Webtrends/wookiee-cluster/badge.svg?branch=master&service=github)](https://coveralls.io/github/Webtrends/wookiee-cluster?branch=master) [![Latest Release](https://img.shields.io/github/release/webtrends/wookiee-cluster.svg)](https://github.com/Webtrends/wookiee-cluster/releases) [![License](http://img.shields.io/:license-Apache%202-red.svg)](http://www.apache.org/licenses/LICENSE-2.0.txt)\r\n\r\n[Main Wookiee Project](https://github.com/Webtrends/wookiee)\r\n\r\nFor Configuration information see [Cluster Config](docs/config.md)\r\n\r\n# Overview\r\n\r\nWith the benefits of distributed cluster of nodes, developers can take advantage of Publish-Subscribe or Send-Subscribe\r\nmessaging patterns. These patterns have the advantage that the sender of messages has no knowledge of the receivers.\r\nThe sender simply uses a 'topic' to send messages to instead of having to know that actual address of the receiver.\r\n\r\nThis pattern allows for our systems to scale by adding additional receivers without the need to change logic or\r\nre-deploy with the knowledge of new receivers.\r\n\r\nFor a working example see [Wookiee - Cluster Example](example-cluster)\r\n\r\n## Basic Usage\r\n\r\nThe system is designed so that a developer simply needs to apply a trait (interface) on an actor in order to have full\r\naccess to this functionality. Wookiee is responsible for managing the peer to peer communication and thus\r\nthe developer of the service does not need to handle any of that information. The act of 'publishing' a message\r\nguarantees that the message will be sent to all subscribers, while 'sending' a message will round-robin to only one of\r\nthe subscribers.\r\n\r\n![](https://webtrends.jiveon.com/servlet/JiveServlet/showImage/102-29731-8-12519/temp.png)\r\n\r\n## Sending/Receiving Messages\r\n\r\nIn order to take full benefit of the functionality one simply needs to apply the trait `MessagingAdapter` and\r\nthen start interacting with the system. When an actor subscribes to a topic it will then receive instances of\r\n`com.webtrends.communication.Message` which is the container that consists of the topic, sender, and\r\nactual message content that was sent or published/sent.\r\n\r\n```scala\r\n\r\nimport com.webtrends.communication.MessagingAdapter\r\nimport com.webtrends.communication.Message\r\n\r\n// Define the actor and have it apply the MessagingAdapter trait\r\nclass MyReceiverActor extends Actor with ActorLoggingAdapter with MessagingAdapter {\r\n    def preStart: Unit = {\r\n        // Subscribe to a specific topic to receive messages from other nodes in the cluster\r\n        subscribe(\"cluster-topic\", self /* I am the receiver, but could be another ActorRef */, false /* this is a subscription for messages from other cluster nodes */)\r\n        // Subscribe to a specific topic to receive messages from other nodes in the cluster and the sender expects a response\r\n        subscribe(\"cluster-topic-with-response\", self /* I am the receiver, but could be another ActorRef */, false /* this is a subscription for messages from other cluster nodes */)\r\n        // Subscribe to a specific topic to receive messages from only within this node\r\n        subscribe(\"internal-topic\", self /* I am the receiver, but could be another ActorRef */, true/* this is a subscription for messages from only this node*/)\r\n    }\r\n    def postStop: Unit = {\r\n        // Unsubscribe from the given topics\r\n        unsubscribe(\"cluster-topic\", self /* I am the receiver, but could be another ActorRef */)\r\n        unsubscribe(\"cluster-topic-with-response\", self /* I am the receiver, but could be another ActorRef */)\r\n        unsubscribe(\"internal-topic\", self /* I am the receiver, but could be another ActorRef */)\r\n        // Alternatively, you can unsubscribe from several topics in one call\r\n        //unsubscribeFromMany(Seq(\"cluster-topic\",\"cluster-topic-with-response\", \"internal-topic\"), self)\r\n    }\r\n    def receive = {\r\n        // The received message is wrapped and includes the senders information as well as the topic and actual message\r\n        case Message(\"cluster-topic\", msg) => // Do something with the message now\r\n        case Message(\"cluster-topic-with-response\", msg) => sender() ! \"an answer\"\r\n    }\r\n}\r\n\r\n// Define the actor and have it apply the MessageServiceAdaptor trait\r\nclass MySenderActor extends Actor with ActorLoggingAdapter with MessagingAdapter {\r\n    def receive = {\r\n        case \"send-external-message\" =>\r\n            // We receive a hypothetical message that tells us to send off a message for a given topic\r\n            send(\"cluster-topic\", SomeMessage(\"somedata\"), false /* I wanted this message to not be handled locally */)\r\n        case \"send-external-message-with-response\" =>\r\n            // We receive a hypothetical message that tells us to send off a message for a given topic and uses a future to handle the response\r\n            sendWithFuture(\"cluster-topic\", SomeMessage(\"somedata\"), false /* I wanted this message to not be handled locally */).onComplete {\r\n                case Success(answer) => // Do something\r\n                case Failure(fail) => // Handle error\r\n            }\r\n        case \"send-internal-message\" =>\r\n            // We receive a hypothetical message that tells us to send off a message for a given topic\r\n            send(\"internal-topic\", SomeMessage(\"somedata\"), true /* I wanted this message to be handled locally */)\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Message Subscription Events\r\nThe ability to receive events for message subscription changes are also available through the trait\r\n`MessageSubscriptionEventAdapter`. If this trait is applied to an actor then the ability to register/unregister\r\nfor events becomes available.\r\n\r\n```scala\r\n\r\nimport com.webtrends.communication.MessageSubscriptionEventAdapter\r\n\r\n// Define the actor and apply the MessageSubscriptionEventAdapter\r\nclass MyEventHandlerActor extends Actor with ActorLoggingAdapter with MessageSubscriptionEventAdapter {\r\n\r\n    def preStart: Unit = {\r\n        // Register for events.This will register for add and remove events, but you can also register for a specific event (e.g. classOf[SubscriptionAddedEvent]).\r\n        register(self, classOf[MessageSubscriptionEvent])\r\n    }\r\n\r\n    def postStop: Unit = {\r\n        // Unregister for the events. This follows the same pattern as registered that is described above\r\n        unregister(self, classOf[MessageSubscriptionEvent])\r\n    }\r\n\r\n    def receive = {\r\n        case SubscriptionAddedEvent(topic, subscriber /* ActorRef */) =>\r\n        // An added subscription event occurred\r\n        case SubscriptionRemovedEvent(topic, subscriber /* ActorRef */) =>\r\n        // A removed subscription event occurred\r\n    }\r\n}\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}